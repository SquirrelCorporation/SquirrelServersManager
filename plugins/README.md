# Developing Plugins for Squirrel Servers Manager

Welcome! This guide provides instructions for developers who want to create and distribute their own plugins for the Squirrel Servers Manager application. Plugins allow you to extend the functionality of the manager by adding new server-side features, API endpoints, and client-side user interfaces.

## Prerequisites

Before you begin, ensure you have the following installed:

*   **Node.js:** (Specify recommended version, e.g., LTS version 18.x or higher)
*   **npm** (usually included with Node.js) or **yarn**

## Getting Started

You can start developing your plugin by setting up a basic Node.js project structure. While a dedicated template repository might be available in the future, you can begin manually:

1.  Create a new project directory for your plugin.
2.  Initialize it as an npm package: `npm init` (follow the prompts).
3.  Install TypeScript and necessary NestJS core dependencies as development dependencies:
    ```bash
    npm install --save-dev typescript @nestjs/common @nestjs/core reflect-metadata rxjs
    # Or using yarn:
    # yarn add --dev typescript @nestjs/common @nestjs/core reflect-metadata rxjs
    ```
4.  Install React, ReactDOM, and Ant Design if you plan to develop client-side components. Note that these should ideally match the versions used by the host application and be configured as shared dependencies (see Client-Side Development section).
    ```bash
    npm install react react-dom antd
    npm install --save-dev @types/react @types/react-dom
    # Or using yarn:
    # yarn add react react-dom antd
    # yarn add --dev @types/react @types/react-dom
    ```
5.  Set up the required project structure and configuration files as described below.

## Plugin Structure

A typical plugin project should follow this structure:

```
your-plugin-name/
├── dist/                     # Compiled server-side code (output of tsc)
├── node_modules/             # Project dependencies
├── public/
│   └── client/               # Bundled client-side assets (output of Webpack)
│       ├── remoteEntry.js    # Module Federation entry point
│       └── [other assets]    # JS chunks, CSS, images, etc.
├── src/
│   ├── client/               # Source files for client-side components (e.g., .tsx)
│   │   └── index.tsx         # Entry point for webpack client build
│   ├── server/               # Source files for server-side logic (NestJS modules, services, controllers)
│   │   └── your-plugin.module.ts # Main NestJS module for the plugin
│   └── index.ts              # Server-side entry point (exports the NestJS module)
├── manifest.json             # Required: Plugin metadata
├── package.json              # Required: Node.js package definition
├── tsconfig.json             # Required: TypeScript configuration
├── webpack.config.js         # Required for client-side components: Webpack configuration
└── .gitignore                # Git ignore file (should ignore node_modules, dist, etc.)
```

**Key Files & Directories:**

*   **`manifest.json`:** Defines essential metadata for your plugin. The host application reads this file first.
*   **`package.json`:** Standard Node.js package file. Lists dependencies. Dependencies shared with the host (like `@nestjs/common`, `react`, `antd`) should often be listed in `peerDependencies`.
*   **`tsconfig.json`:** Configures the TypeScript compiler (`tsc`). Ensure `outDir` is set to `"./dist"` and `baseUrl` to `"./src"`.
*   **`webpack.config.js`:** Configures Webpack for bundling client-side components using Module Federation. *Crucial for plugins with UI.*
*   **`src/index.ts`:** The main entry point for the server-side part of your plugin. It **must** export a valid NestJS module class (decorated with `@Module`).
*   **`dist/`:** Contains the compiled JavaScript output from `tsc`. This is the code the host application will load for the server-side logic.
*   **`public/client/`:** Contains the bundled JavaScript and other static assets (CSS, images) generated by Webpack for the client-side part of your plugin. This specific path is required.

## `manifest.json` Specification

This file is crucial for the host application to understand and load your plugin.

```json
{
  "id": "your-plugin-kebab-case-id", // Required: Unique identifier (use kebab-case). Used for routing and internal mapping.
  "name": "Your Plugin Name",        // Required: Human-readable name
  "version": "1.0.0",               // Required: Plugin version (semver)
  "description": "A brief description of what your plugin does.", // Required
  "entryPoint": "dist/index.js",    // Required: Path (relative to archive root) to the compiled server entry point
  "client": {                       // Optional: Include only if your plugin has client-side components
    "remoteEntryRelativePath": "public/client/remoteEntry.js", // Required if "client" exists: Path to the MF entry point
    "exposedModule": "./YourPluginComponent", // Required if "client" exists: The module exposed via Webpack (e.g., the main UI component)
    "componentName": "YourPluginComponent",    // Required if "client" exists: The name of the component to render
    "hasDedicatedPage": true             // Optional: If true, creates a route /plugins/<plugin-id> for this component
  },
  "author": "Your Name or Company",   // Optional
  "license": "MIT"                    // Optional
}
```

*   **`id`:** REQUIRED. Must be a unique identifier for your plugin across the entire system. Use **kebab-case** (e.g., `my-awesome-feature`). This ID is critical as it's used in the URL for dedicated plugin pages (`/plugins/<id>`) and for internal plugin management.
*   **`name`:** REQUIRED. Human-readable name for display purposes.
*   **`version`:** REQUIRED. Plugin version following semantic versioning.
*   **`description`:** REQUIRED. A brief description of the plugin's purpose.
*   **`entryPoint`:** REQUIRED. Must point to the main JavaScript file generated by `tsc` inside the `dist` directory (relative to the archive root).
*   **`client` section:** (Optional) Include only if your plugin has client-side components:
    *   `remoteEntryRelativePath`: REQUIRED if `client` exists. Must point to `public/client/remoteEntry.js`.
    *   `exposedModule`: REQUIRED if `client` exists. The key used in the `exposes` section of your `webpack.config.js`.
    *   `componentName`: REQUIRED if `client` exists. The name of the React component exported by the `exposedModule`.
    *   `hasDedicatedPage` (Optional, boolean): If set to `true`, the host application will automatically create a dedicated route for this plugin at `/plugins/<your-plugin-kebab-case-id>`. This route will render the component specified by `exposedModule` and `componentName`.
*   **`author`:** (Optional) The author's name or company.
*   **`license`:** (Optional) The license under which the plugin is distributed.

## Server-Side Development (NestJS)

The server-side logic of your plugin should be implemented using NestJS modules, controllers, and providers.

*   **Entry Point (`src/index.ts`):** This file must export a single NestJS module class. This module will be dynamically imported and registered by the host application.
    ```typescript
    // src/index.ts
    import { Module } from '@nestjs/common';
    import { YourPluginServerModule } from './server/your-plugin.module';

    @Module({
      imports: [YourPluginServerModule], // Import your plugin's main server module
      // controllers: [], // Avoid defining controllers here
      // providers: [],   // Avoid defining providers here
      // exports: [],     // Avoid defining exports here
    })
    export class MainPluginEntryModule {} // This is the class the host imports
    ```
*   **Main Module (`src/server/your-plugin.module.ts`):** Define your controllers, providers, and any imports needed for your plugin's backend functionality here.
    ```typescript
    // src/server/your-plugin.module.ts
    import { Module } from '@nestjs/common';
    import { YourPluginController } from './your-plugin.controller';
    import { YourPluginService } from './your-plugin.service';

    @Module({
      controllers: [YourPluginController],
      providers: [YourPluginService],
      // imports: [], // Import other modules if needed
    })
    export class YourPluginServerModule {}
    ```
*   **Dependencies:** List core NestJS dependencies (`@nestjs/common`, `@nestjs/core`, `reflect-metadata`, `rxjs`) and potentially others shared with the host (like `typeorm` if used) in `peerDependencies` and `devDependencies` in your `package.json`. Avoid bundling them directly. Application-specific dependencies can be regular `dependencies`.

## Client-Side Development (React & Module Federation)

If your plugin provides a user interface component to be integrated into the main application, you **must** use Webpack and Module Federation.

**Critical `webpack.config.js` Settings:**

This configuration ensures your plugin's client-side code can be correctly loaded and integrated by the host application.

```javascript
const path = require("path");
const webpack = require("webpack");
const { ModuleFederationPlugin } = webpack.container;

// IMPORTANT: Use kebab-case matching your manifest.json 'id'
const pluginKebabCaseId = "your-plugin-kebab-case-id";

// IMPORTANT: Use camelCase derived from your kebab-case id
// This MUST match the 'name' and 'library.name' expected by the host loader
const pluginCamelCaseName = "yourPluginCamelCaseId"; // e.g., 'myAwesomeFeature' from 'my-awesome-feature'

// Define dependencies shared with the host application
// Ensure these match the host's versions where possible
const sharedConfig = {
  react: { singleton: true, requiredVersion: false },
  "react-dom": { singleton: true, requiredVersion: false },
  antd: { singleton: true, requiredVersion: false },
  // Add other shared libs matching the host config if needed
};

module.exports = {
  mode: process.env.NODE_ENV || "development",
  entry: "./src/client/index.tsx", // Your client entry point
  output: {
    // IMPORTANT: Output MUST be to 'public/client'
    path: path.resolve(__dirname, "public/client"),
    // IMPORTANT: publicPath structure MUST follow this pattern
    publicPath: `/static-plugins/client/${pluginKebabCaseId}/`,
    clean: true,
  },
  resolve: {
    extensions: [".tsx", ".ts", ".js", ".jsx"],
  },
  module: {
    rules: [
      // Add loaders for .ts, .tsx, .css, etc.
      {
        test: /\.(ts|tsx)$/,
        exclude: /node_modules/,
        use: ["ts-loader"],
      },
      // Example CSS loader
      // {
      //   test: /\.css$/i,
      //   use: ['style-loader', 'css-loader'],
      // },
    ],
  },
  plugins: [
    new ModuleFederationPlugin({
      // IMPORTANT: 'name' MUST be the camelCase version of your plugin ID
      name: pluginCamelCaseName,
      // IMPORTANT: 'library' config is required
      library: { type: "window", name: pluginCamelCaseName }, // Must match 'name'
      // IMPORTANT: 'filename' MUST be 'remoteEntry.js'
      filename: "remoteEntry.js",
      exposes: {
        // Key MUST match 'exposedModule' in manifest.json
        // Value is the relative path to your component file
        "./YourPluginComponent": "./src/client/YourPluginComponent.tsx",
      },
      shared: sharedConfig,
    }),
  ],
  devtool: "source-map", // Optional: for debugging
};
```

**Key Points for Client-Side:**

*   **Naming Convention:** Use kebab-case for your plugin `id` in `manifest.json` and for the `publicPath`. Use the corresponding camelCase version for the `ModuleFederationPlugin` `name` and `library.name`.
*   **Output Path:** Webpack output *must* go to the `public/client` directory.
*   **Public Path:** The `output.publicPath` *must* follow the structure `/static-plugins/client/<plugin-kebab-case-id>/`.
*   **Module Federation Name:** The `name` and `library.name` in `ModuleFederationPlugin` *must* be the camelCase version of your plugin ID. The host application expects this specific name (`window.yourPluginCamelCaseId`) to be globally available after loading `remoteEntry.js`.
*   **Exposes:** The key used in `exposes` (e.g., `./YourPluginComponent`) must exactly match the `client.exposedModule` value in your `manifest.json`.
*   **Shared Dependencies:** Carefully configure shared dependencies (`react`, `react-dom`, `antd`, etc.) to ensure compatibility and avoid loading multiple copies. Mark them as `singleton: true`. List them in `peerDependencies` in `package.json`.

## Building the Plugin

You need a build script in your `package.json` that compiles both the server and client code.

```json
// package.json (scripts section)
"scripts": {
  "build:server": "tsc -p tsconfig.json",
  "build:client": "webpack --mode production",
  "build": "npm run build:server && npm run build:client",
  "clean": "rm -rf dist public/client ${npm_package_name}-*.tar.gz ${npm_package_name}-*.sha256",
  "prepackage": "npm run clean && npm run build && npm install --omit=dev",
  "package": "tar czf ${npm_package_name}-v${npm_package_version}.tar.gz --exclude='src' --exclude='*.tsbuildinfo' --exclude='webpack.config.js' --exclude='tsconfig.json' --exclude='.git' --exclude='.gitignore' --exclude='${npm_package_name}-*.tar.gz' --exclude='${npm_package_name}-*.sha256' manifest.json package.json dist public node_modules && shasum -a 256 ${npm_package_name}-v${npm_package_version}.tar.gz > ${npm_package_name}-v${npm_package_version}.tar.gz.sha256",
  "postpackage": "npm install"
},
```

Run the build command:

```bash
npm run build
```

This should:
1.  Clean previous builds (optional but recommended).
2.  Compile server-side TypeScript using `tsc` into the `dist/` folder.
3.  Bundle client-side assets using `webpack` into the `public/client/` folder.

## Packaging for Distribution

Plugins are distributed as `.tar.gz` archives. The archive **must** contain the necessary files at its root.

To simplify and standardize packaging, it's recommended to add packaging scripts to your plugin's `package.json`:

```json
// package.json (scripts section additions)
"scripts": {
  // ... other scripts like build:server, build:client, build ...
  "clean": "rm -rf dist public/client ${npm_package_name}-*.tar.gz ${npm_package_name}-*.sha256",
  "prepackage": "npm run clean && npm run build && npm install --omit=dev",
  "package": "tar czf ${npm_package_name}-v${npm_package_version}.tar.gz --exclude='src' --exclude='*.tsbuildinfo' --exclude='webpack.config.js' --exclude='tsconfig.json' --exclude='.git' --exclude='.gitignore' --exclude='${npm_package_name}-*.tar.gz' --exclude='${npm_package_name}-*.sha256' manifest.json package.json dist public node_modules && shasum -a 256 ${npm_package_name}-v${npm_package_version}.tar.gz > ${npm_package_name}-v${npm_package_version}.tar.gz.sha256",
  "postpackage": "npm install"
},
```

With these scripts in place, you can package your plugin by running:

```bash
npm run package
```

This command will:
1.  Clean old build artifacts and packages (`clean`).
2.  Run the build (`build`).
3.  Install only production dependencies (`prepackage`).
4.  Create the `.tar.gz` archive containing the required files (`package`):
    *   `manifest.json`
    *   `package.json`
    *   `dist/` (compiled server code)
    *   `public/` (client assets)
    *   `node_modules/` (production dependencies)
5.  Generate a SHA256 checksum file (`<plugin-name>-v<version>.tar.gz.sha256`) for the archive (`package`).
6.  Reinstall all dependencies, including development ones (`postpackage`).

The resulting `.tar.gz` file (e.g., `your-plugin-name-v1.0.0.tar.gz`) is what you distribute for installation in the Squirrel Servers Manager.

*Note: Ensure your `.gitignore` file excludes the generated `.tar.gz` and `.sha256` files.*

## Troubleshooting

*   **`Can't resolve 'react-dom'` (or other shared dependencies) during Webpack build:**
    *   Ensure the dependency is listed in `package.json` (`dependencies` or `peerDependencies`).
    *   Run `npm install` to make sure it's present in `node_modules`.
    *   Verify the `shared` configuration in `webpack.config.js` is correct.
*   **`Remote container not found: yourPluginCamelCaseId` in Host Application Console:**
    *   Double-check that `ModuleFederationPlugin.name` and `ModuleFederationPlugin.library.name` in `webpack.config.js` exactly match the expected camelCase ID.
    *   Verify the `output.publicPath` is correctly set to `/static-plugins/client/<plugin-kebab-case-id>/`.
    *   Ensure the `client.remoteEntryRelativePath` in `manifest.json` points to `public/client/remoteEntry.js`.
    *   Check the browser's network tab to confirm `remoteEntry.js` is loading successfully (Status 200).
    *   Verify the `entryPoint` in `manifest.json` correctly points to the compiled `dist/index.js`.
    *   Ensure `src/index.ts` exports a valid NestJS module.
    *   Check server logs for errors during plugin loading.
    *   Make sure all runtime `dependencies` listed in `package.json` are included in the packaged `node_modules` within the `.tar.gz` archive.